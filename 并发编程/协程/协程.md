* Go原生支持应用之间的通信和程序的并发
* Go 语言为构建并发程序的基本代码块是 协程 (goroutine) 与通道 (channel)
* **不要通过共享内存来通信，而通过通信来共享内存**

# 并发 & 并行

* 并发：在同一时间段内，多个任务在同一个处理器上交替执行
* 并行：多个任务在同一时间同时执行
* 并发程序可以是并行的，也可以不是。

# 进程 & 线程

1. 一个应用程序是运行在机器上的一个进程；进程是一个运行在自己**内存地址空间**里的独立执行体
2. 一个进程由多个操作系统线程组成，这些线程共享进程的的内存地址空间，配合一起工作的执行体

# 协程

* 轻量级：比线程更轻。创建非常廉价：使用 4K 的栈内存就可以在堆中创建它们。必要的时候可以轻松创建并运行大量的协程
* 栈的管理是自动的，但不是由垃圾回收器管理的，而是在协程退出后自动释放。
* 协程可以运行在多个操作系统线程之间，也可以运行在线程之内，让你可以很小的内存占用就可以处理大量的任务

## 协程调度器

# 数据共享问题

使用多线程的应用难以做到准确，最主要的问题是**内存中的数据共享**。它们会被多线程以无法预知的方式进行操作，导致一些无法重现或者随机的结果
**不要使用全局变量或者共享内存，它们会给你的代码在并发运算的时候带来危险**

## 解决方案1：对数据加锁

同步不同的线程，对数据加锁，这样同时就只有一个线程可以变更数据。
缺点：这会带来更高的复杂度，更容易使代码出错以及更低的性能，所以这个经典的方法明显不再适合现代多核 /
多处理器编程：thread-per-connection 模型不够有效

## 解决方案2：Communicating Sequential Processes（顺序通信处理）/ message passing-model（消息传递

# chan

* 协程可以使用共享变量来通信，但是很不提倡这样做
* Go 有一个特殊的类型，通道（channel），像是通道（管道），可以通过它们发送类型化的数据在协程之间通信，可以避开所有内存共享导致的坑
* 通道的通信方式保证了 **同步性**。
* 数据通过通道：同一时间只有一个协程可以访问数据：所以**不会出现数据竞争**

## 定义

* channel是引用类型
* 未初始化的通道的值是 nil
* 通道只能传输一种类型的数据，比如 chan int 或者 chan string，所有的类型都可以用于通道，空接口 interface{}
  也可以。甚至可以（有时非常有用）创建通道的通道。
* 通道实际上是类型化消息的队列：使数据得以传输。它是先进先出（FIFO）的结构所以可以保证发送给他们的元素的顺序

## 无缓冲channel

* 默认情况下，通信是同步且无缓冲的。在有接收者接收数据之前，发送不会结束。可以想象一个无缓冲的通道在没有空间来保存数据的时候：必须要一个接收者准备好接收通道的数据然后发送者可以直接把数据发送给接收者。
**所以通道的发送 / 接收操作在对方准备好之前是阻塞的**

* 通过通道，两个协程在通信中某刻同步交换数据。无缓冲通道成为了多个**协程同步**的完美工具。甚至可以在通道两端互相阻塞对方，形成了叫做死锁的状态

```go
package main

import (
	"fmt"
	"time"
)

func f1(in chan int) {
	fmt.Println(<-in)
}

func main() {
	out := make(chan int)
	//out <- 2 // 代码执行到这，没有协程接受，所以把这段代码放到 go f1(out)下面就行
	go f1(out)
	out <- 2
	time.Sleep(1)
}
```

## 缓冲channel
* 在缓冲满载（缓冲被全部使用）之前，给一个带缓冲的通道发送数据是不会阻塞的，而从通道读取数据也不会阻塞，直到缓冲空了。



# 协程中用通道输出结果


# select
```go
select {
case u:= <- ch1:
        ...
case v:= <- ch2:
        ...
        ...
default: // no value ready to be received
        ...
}
```
* 如果都阻塞了，会等待直到其中一个可以处理
* 如果多个可以处理，随机选择一个
* 如果没有通道操作可以处理并且写了 default 语句，它就会执行：default 永远是可运行的（这就是准备好了，可以执行）
* select 语句实现了一种监听模式，通常用在（无限）循环中；在某种情况下，通过 break 语句使循环退出。