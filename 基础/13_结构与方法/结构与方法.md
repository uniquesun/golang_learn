# 来源
* 前面的基本类型和array，slice，map，都是确定的单一数据类型
* 但很多时候，我们是需要复合数据类型的。GO支持**类型别名**和**结构体**的方式支持**用户自定义类型**

# 概念
* 结构体也是**值类型**，因此可以通过 new 函数来创建。
* 组成结构体类型的那些数据称为 字段（fields）。每个字段都有一个类型和一个名字；在一个结构体中，字段名字必须是唯一的。
* Go语言没有类的概念，`可以想象成结构体是没有方法的类`

# 定义
* 结构体里的字段都有 名字，像 field1、field2 等，如果字段在代码中从来也不会被用到，那么可以命名它为 _。
* 结构体的字段可以是任何类型，甚至是**结构体本身**，也可以是**函数**或者**接口**
* 结构体可以包含一个或多个 匿名（或内嵌）字段，即这些字段没有显式的名字，只有字段的类型是必须的，此时类型就是字段的名字。匿名字段本身可以是一个结构体类型，即 结构体可以包含内嵌结构体

# 内存布局
* Go 语言中，结构体和它所包含的数据在内存中是以连续块的形式存在的，即使结构体中嵌套有其他的结构体

# 内嵌结构体（继承）
* 在一个结构体中对于每一种数据类型只能有一个匿名字段。
* 当两个字段拥有相同的名字（可能是继承来的名字）时该怎么办呢？
  * 外层名字会覆盖内层名字（但是两者的内存空间都保留），这提供了一种重载字段或方法的方式；
  * 如果相同的名字在同一级别出现了两次，如果这个名字被程序使用了，将会引发一个错误（不使用没关系）。没有办法来解决这种问题引起的二义性，必须由程序员自己修正。


# 方法
* 方法可以用在结构体上，也可以用在非结构体上
* 类型和作用在它上面定义的方法必须在同一个包里定义类型和作用在它上面定义的方法必须在同一个包里定义。这就是为什么不能在 int、float 或类似这些的类型上定义方法

```golang
func (recv receiver_type) methodName(parameter_list) (return_value_list) { ... }
```
* 如果 recv 是 receiver 的实例，Method1 是它的方法名，那么方法调用遵循传统的 object.name 选择器符号：recv.Method1()。
* 如果 recv 一个指针，Go 会自动解引用。

## 函数与方法的区别
* 函数将变量作为参数：Function1(recv)
* 方法在变量上被调用：recv.Method1()


# 通用方法和方法命名
在编程中一些基本操作会一遍又一遍的出现，比如打开（Open）、关闭（Close）、读（Read）、写（Write）、排序（Sort）等等

# 面向对象

## 封装
```go
package main

import "fmt"

type Person struct {
	firstName string
	lastName  string
}

func (p *Person) SetFirstName(firstName string) {
	fmt.Println("Person 执行")
	p.firstName = firstName
}
func (p *Person) GetFirstName() string {
	return p.firstName
}
```
对象的字段（属性）不应该由 2 个或 2 个以上的不同线程在同一时间去改变。如果在程序发生这种情况，为了安全并发访问，可以使用包 sync（参考第 9.3 节）中的方法。在第 14.17 节中我们会通过 goroutines 和 channels 探索另一种方式。

## 多重继承
* 当外部结构体和嵌入的结构体有**同名的字段或方法时**，会发生名字冲突。在这种情况下，外部结构体的字段或方法会**覆盖**嵌入结构体的同名字段或方法。这种机制被称为“提升”或“覆盖”，
* 为了访问被覆盖的字段或方法，你需要使用嵌入结构体的类型名作为选择器
```go
package main

import "fmt"

// Person 封装
type Person struct {
	FirstName string
	LastName  string
}

func (p *Person) SetFirstName(firstName string) {
	fmt.Println("Person 执行")
	p.FirstName = firstName
}
func (p *Person) GetFirstName() string {
	return p.FirstName
}

type Student struct {
	Person
	Score     float32
	FirstName string
}

func (s *Student) SetFirstName(fistName string) {
	fmt.Println("student 执行")
	s.FirstName = fistName
}

func main() {
	//p1 := new(Person)
	//p1.SetFirstName("olaf")
	//fmt.Println(p1.GetFirstName())

	s1 := &Student{
		Person:    Person{"olaf", "loong"},
		Score:     100,
		FirstName: "jie",
	}

	// 获取同名的属性
	fmt.Println(s1.FirstName) // jie
	// 获取嵌入结构体属性
	fmt.Println(s1.Person.FirstName) // olaf

	// 执行方法
	s1.SetFirstName("olaf student")
	// 执行嵌入结构体方法
	s1.Person.SetFirstName("xixi")
	//fmt.Println(s1.GetFirstName())
}
```



# 总结
* 在 Go 中，类型就是类（数据和关联的方法）。Go 拥有类似面向对象语言的类继承的概念。继承有两个好处：代码复用和多态。
* 在 Go 中，**代码复用通过组合和委托实现**，**多态通过接口的使用来实现**：有时这也叫 组件编程（Component Programming）。