Go有非常灵活的接口概念，通过它可以实现很多面向对象的特性

接口提供了一种方式来 说明 对象的行为：如果谁能搞定这件事，它就可以用在这儿。

# 定义

* 接口定义了一组方法（方法集），但是这些方法不包含（实现）代码：它们没有被实现（它们是抽象的）
* 接口里也不能包含变量
* 一个接口类型的变量或一个 接口值 ：var ai Namer，ai 是一个多字（multiword）数据结构，它的值是 nil。它本质上是一个指针

# 实现接口

* 类型不需要显式声明它实现了某个接口：**接口被隐式地实现**。多个类型可以实现同一个接口。
* 类型（比如结构体）实现接口方法集中的方法，每一个方法的实现说明了此方法是如何作用于该类型的：即**实现接口**
* 实现某个接口的类型（除了实现接口方法外）可以有其他的方法。
* 一个类型可以实现多个接口
* 接口类型可以包含一个实例的引用， 该实例的类型实现了此接口（接口是动态类型）。
* 即使接口在类型之后才定义，二者处于不同的包中，被单独编译：只要类型实现了接口中的方法，它就实现了此接口。

总结：只要你实现了接口里的所有方法就行

```go
package main

import "fmt"

// Shaper 图形接口
type Shaper interface {
	Area() float32
}

// Square 正方形
type Square struct {
	side float32
}

// Area 类型实现了图形接口
func (s *Square) Area() float32 {
	return s.side * s.side
}

// Rectangle 长方形
type Rectangle struct {
	length, width float32
}

func (r *Rectangle) Area() float32 {
	return r.length * r.width
}

func main() {
	//sq1 := new(Square)
	//sq1.side = 5
	//
	//// 接口类型
	//var areaIntf Shaper
	//fmt.Println(areaIntf) // nil
	//areaIntf = sq1
	//
	//fmt.Printf("The square has area: %f\n", areaIntf.Area())

	// 多态
	r := &Rectangle{5, 3}
	q := &Square{5}
	shapes := []Shaper{r, q}
	fmt.Println("Looping through shapes for area ...")
	for n, _ := range shapes {
		fmt.Println("Shape details: ", shapes[n])
		fmt.Println("Area of this shape is: ", shapes[n].Area()) // Area方法走不通的方法
	}
}
```

# 接口嵌套

* 一个接口可以包含一个或多个其他的接口，这相当于直接将这些内嵌接口的方法列举在外层接口中一样。

```go
type ReadWrite interface {
Read(b Buffer) bool
Write(b Buffer) bool
}

type Lock interface {
Lock()
Unlock()
}

type File interface {
ReadWrite
Lock
Close()
}
```

# 类型断言（获取变量的实际类型）

* 一个接口类型的变量 varI 中可以包含任何类型的值，必须有一种方式来检测它的 动态 类型，即运行时在变量中存储的值的实际类型

```go
areaIntf.(*Square)
```

# 总结

* 封装（数据隐藏）：和别的 OO 语言有 4 个或更多的访问层次相比，Go 把它简化为了 2 层（参见 4.2 节的可见性规则）:
1）包范围内的：通过标识符首字母小写，对象 只在它所在的包内可见
2）可导出的：通过标识符首字母大写，对象 对所在包以外也可见

* 继承：用组合实现：内嵌一个（或多个）包含想要的行为（字段和方法）的类型；多重继承可以通过内嵌多个类型实现
* 多态：用接口实现：某个类型的实例可以赋给它所实现的任意接口类型的变量。类型和接口是松耦合的，并且多重继承可以通过实现多个接口实现。